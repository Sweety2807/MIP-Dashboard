<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ðŸ“… MIP Calendar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- CSV + date parsing libs -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/customParseFormat.js"></script>
  <style>
    body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;margin:24px;}
    table{border-collapse:collapse;width:100%;table-layout:fixed}
    th,td{border:1px solid #e5e7eb}
    thead th{position:sticky;top:0;background:#f8fafc;z-index:3}
    tbody th{background:#fff}
    .container{overflow:auto;max-width:100%}
    .controls>*{margin-right:12px}
    #q{padding:6px 10px;border:1px solid #cbd5e1;border-radius:8px}
    .chip{padding:4px 8px;border-radius:8px;margin-left:8px;display:inline-block}
    .panel{border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin:8px 0 16px 0;background:#fafafa}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    select,input[type="text"]{padding:6px 10px;border:1px solid #cbd5e1;border-radius:8px}
    button{padding:6px 10px;border:1px solid #cbd5e1;border-radius:8px;background:#fff;cursor:pointer}
  </style>
</head>
<body>
  <h1>ðŸ“… MIP Calendar</h1>
  <p><strong>Rows:</strong> Name &amp; Subject (separate columns) &nbsp;&nbsp;
     <strong>Columns:</strong> Date &nbsp;&nbsp;
     <strong>Cells:</strong> MIP (or <em>Absent</em>)</p>
  <div style="margin:8px 0 16px 0;">
    <strong>Legend:</strong>
    <span class="chip" style="background:#A5D6A7;">On Track</span>
    <span class="chip" style="background:#FFF59D;">Spend More Time</span>
    <span class="chip" style="background:#EF9A9A;">Low Efficiency / Idling</span>
    <span class="chip" style="background:#CFD8DC;">Absent</span>
    <span class="chip" style="background:#EEEEEE;">No Data</span>
  </div>

  <!-- Mapping panel -->
  <div class="panel">
    <div class="row">
      <div>
        <label>MIP CSV:</label>
        <input id="mipFileName" value="mip.csv" style="width:180px"/>
      </div>
      <div>
        <label>Absent CSV (optional):</label>
        <input id="absFileName" value="absent.csv" style="width:180px"/>
      </div>
      <button id="reload">Load CSVs</button>
    </div>
    <div class="row" style="margin-top:10px">
      <div>
        <label>Name column:</label>
        <select id="nameCol"></select>
      </div>
      <div>
        <label>Subject column:</label>
        <select id="subjCol"></select>
      </div>
      <div>
        <label>MIP column:</label>
        <select id="mipCol"></select>
      </div>
      <div>
        <label>Date column:</label>
        <select id="dateCol"></select>
      </div>
      <div>
        <label>Date format:</label>
        <select id="dateFmt">
          <option value="auto">Auto detect</option>
          <option value="DD/MM/YYYY">DD/MM/YYYY (e.g. 31/08/2025)</option>
          <option value="MM/DD/YYYY">MM/DD/YYYY (e.g. 08/31/2025)</option>
          <option value="YYYY-MM-DD">YYYY-MM-DD</option>
          <option value="DD-MM-YYYY">DD-MM-YYYY</option>
          <option value="YYYY/MM/DD">YYYY/MM/DD</option>
        </select>
      </div>
      <button id="build">Build Calendar</button>
    </div>
  </div>

  <div class="controls" style="margin:8px 0 12px 0;">
    <label>Search:</label> <input id="q" placeholder="Type name or subject..." />
  </div>
  <div id="subjects"></div>

  <div class="container" style="margin-top:8px;">
    <table>
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <p id="status" style="margin-top:12px;color:#64748b;"></p>

<script>
dayjs.extend(dayjs_plugin_customParseFormat);

// ---- config & colors ----
const HOVER_INDICES = [4,5,6,7,8,9,12]; // E..J & M (0-based positions in the *original* CSV)
const COLOR = {
  onTrack: '#A5D6A7', spendMore: '#FFF59D', red: '#EF9A9A', absent: '#CFD8DC', none: '#EEEEEE'
};

// ---- state ----
let mipRows = [], absRows = [];
let allCols = [];
const els = {
  nameCol: document.getElementById('nameCol'),
  subjCol: document.getElementById('subjCol'),
  mipCol:  document.getElementById('mipCol'),
  dateCol: document.getElementById('dateCol'),
  dateFmt: document.getElementById('dateFmt'),
  thead:   document.getElementById('thead'),
  tbody:   document.getElementById('tbody'),
  q:       document.getElementById('q'),
  status:  document.getElementById('status'),
  subjects:document.getElementById('subjects'),
  mipFileName: document.getElementById('mipFileName'),
  absFileName: document.getElementById('absFileName'),
};

// ---- helpers ----
const parseCSV = async (url) => {
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
  const text = await res.text();
  return new Promise((resolve, reject) => {
    Papa.parse(text, {header:true, skipEmptyLines:true, complete: r=>resolve(r.data), error: reject});
  });
};

const findCol = (rows, candidates) => {
  if (!rows.length) return null;
  const cols = Object.keys(rows[0]);
  for (const cand of candidates) {
    const hit = cols.find(c => c.toLowerCase() === cand.toLowerCase());
    if (hit) return hit;
  }
  for (const cand of candidates) {
    const hit = cols.find(c => c.toLowerCase().includes(cand.toLowerCase()));
    if (hit) return hit;
  }
  return null;
};

const toISODate = (v, fmt) => {
  if (!v) return null;
  if (fmt && fmt !== 'auto') {
    const d = dayjs(v, fmt, true);
    return d.isValid() ? d.format('YYYY-MM-DD') : null;
  }
  // auto: try native, then common formats
  let d = dayjs(v);
  if (!d.isValid()) d = dayjs(v, 'YYYY-MM-DD', true);
  if (!d.isValid()) d = dayjs(v, 'DD/MM/YYYY', true);
  if (!d.isValid()) d = dayjs(v, 'MM/DD/YYYY', true);
  if (!d.isValid()) d = dayjs(v, 'DD-MM-YYYY', true);
  if (!d.isValid()) d = dayjs(v, 'YYYY/MM/DD', true);
  return d.isValid() ? d.format('YYYY-MM-DD') : null;
};

const statusColor = (val) => {
  if (val == null || val === "") return COLOR.none;
  const s = String(val).trim().toLowerCase();
  if (s === "on track") return COLOR.onTrack;
  if (s === "spend more time") return COLOR.spendMore;
  if (s === "probable idling/inflated time" || s.includes("low efficiency") || s.includes("idling") || s.includes("inflated")) return COLOR.red;
  return COLOR.none;
};

const esc = (s) => String(s ?? "").replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));

// ---- load & guess columns ----
async function loadCSVs() {
  els.status.textContent = 'Loading...';
  try {
    mipRows = await parseCSV(els.mipFileName.value.trim());
    els.status.textContent = 'Loaded ' + els.mipFileName.value.trim();
  } catch(e) {
    els.status.textContent = 'Could not load ' + els.mipFileName.value.trim() + ': ' + e.message;
    mipRows = [];
  }
  try {
    absRows = await parseCSV(els.absFileName.value.trim());
    els.status.textContent += ' + ' + els.absFileName.value.trim();
  } catch { absRows = []; }

  if (!mipRows.length) return;

  allCols = Object.keys(mipRows[0]);
  const guesses = {
    name:  findCol(mipRows, ['name','student name','learner','child']) || allCols[0],
    subj:  findCol(mipRows, ['subject','course','class']) || '',
    mip:   findCol(mipRows, ['mip','status','progress','metric']) || allCols.find(c=>/mip|status|progress|metric/i.test(c)) || allCols[0],
    date:  findCol(mipRows, ['date','activity date','session date','day']) || allCols.find(c=>/date|day/i.test(c)) || allCols[0],
  };

  // populate selects
  const fill = (sel, allowEmpty=false) => {
    sel.innerHTML = allowEmpty ? '<option value="">(none)</option>' : '';
    for (const c of allCols) sel.innerHTML += `<option value="${esc(c)}">${esc(c)}</option>`;
  };
  fill(els.nameCol); fill(els.subjCol, true); fill(els.mipCol); fill(els.dateCol);

  els.nameCol.value = guesses.name;
  els.subjCol.value = guesses.subj;
  els.mipCol.value  = guesses.mip;
  els.dateCol.value = guesses.date;
}

// ---- build calendar ----
function buildCalendar() {
  const nameCol = els.nameCol.value;
  const subjCol = els.subjCol.value || null;
  const mipCol  = els.mipCol.value;
  const dateCol = els.dateCol.value;
  const fmt     = els.dateFmt.value;

  if (!mipRows.length) { els.status.textContent = 'Load CSVs first.'; return; }

  // Normalize dates & build keys
  const rows = mipRows
    .map(r => {
      const iso = toISODate(r[dateCol], fmt);
      if (!iso) return null;
      const rowKey = subjCol ? JSON.stringify([String(r[nameCol]||''), String(r[subjCol]||'')]) : String(r[nameCol]||'');
      return {
        __date: iso,
        __row: rowKey,
        __name: String(r[nameCol]||''),
        __subj: subjCol ? String(r[subjCol]||'') : '',
        __mip:  r[mipCol],
        _raw: r
      };
    })
    .filter(Boolean);

  if (!rows.length) {
    els.status.textContent = 'No valid dates after parsing. Try another Date format.';
    return;
  }

  // tooltips from E..J and M by index
  const mkTip = (r) => {
    const parts = [];
    for (const idx of HOVER_INDICES) {
      const k = allCols[idx];
      if (k) parts.push(`${k}: ${r._raw[k] ?? ''}`);
    }
    return parts.join('\n');
  };

  // keep last per (__row,__date)
  const map = new Map();
  rows.forEach(r => map.set(r.__row + '|' + r.__date, r));
  const dedup = Array.from(map.values());

  // absences
  const absPairs = new Set();
  const absNameDate = new Set();
  if (absRows.length) {
    const aName = findCol(absRows, [nameCol,'name','student name','learner','child']) || Object.keys(absRows[0])[0];
    const aSubj = subjCol ? findCol(absRows, [subjCol,'subject','course','class']) : null;
    const aDate = findCol(absRows, ['date','activity date','session date','day']) || dateCol;
    const aFlag = findCol(absRows, ['absent','attendance','status']);

    absRows.forEach(r => {
      const iso = toISODate(r[aDate], fmt) || toISODate(r[aDate], 'auto');
      const flag = aFlag ? String(r[aFlag]||'').trim().toLowerCase() : 'absent';
      const isAbsent = ['absent','a','true','1','yes'].includes(flag) || (aFlag==null);
      if (!iso || !isAbsent) return;
      if (aSubj) {
        const key = JSON.stringify([String(r[aName]||''), String(r[aSubj]||'')]);
        absPairs.add(JSON.stringify([key, iso]));
      } else {
        absNameDate.add(JSON.stringify([String(r[aName]||''), iso]));
      }
    });
  }

  // row keys & dates
  const rowKeys = Array.from(new Set(dedup.map(r => r.__row)));
  const dates = Array.from(new Set(dedup.map(r => r.__date))).sort();

  // maps
  const valMap = new Map();
  const tipMap = new Map();
  dedup.forEach(r => {
    const key = r.__row + '|' + r.__date;
    valMap.set(key, r.__mip);
    tipMap.set(key, mkTip(r));
  });

  // render header
  els.thead.innerHTML = '';
  const trh = document.createElement('tr');
  const thN = document.createElement('th'); thN.style.position='sticky'; thN.style.left='0'; thN.style.background='#fafafa'; thN.style.zIndex='3'; thN.textContent='Name';
  const thS = document.createElement('th'); thS.style.position='sticky'; thS.style.left='120px'; thS.style.background='#fafafa'; thS.style.zIndex='3'; thS.textContent='Subject';
  trh.append(thN, thS);
  dates.forEach(d => { const th=document.createElement('th'); th.textContent=d; trh.appendChild(th); });
  els.thead.appendChild(trh);

  // rows
  els.tbody.innerHTML = '';
  const subjects = new Set();
  rowKeys.forEach(rowKey => {
    let name = rowKey, subject = '';
    try { const a=JSON.parse(rowKey); name=a[0]; subject=a[1]||''; } catch {}
    if (subject) subjects.add(subject);

    const tr = document.createElement('tr');
    tr.setAttribute('data-subject', subject || '');

    const th1 = document.createElement('th'); th1.style.position='sticky'; th1.style.left='0'; th1.style.background='#fff'; th1.style.zIndex='2'; th1.style.textAlign='left'; th1.style.whiteSpace='nowrap'; th1.textContent = name || '';
    const th2 = document.createElement('th'); th2.style.position='sticky'; th2.style.left='120px'; th2.style.background='#fff'; th2.style.zIndex='2'; th2.style.textAlign='left'; th2.style.whiteSpace='nowrap'; th2.textContent = subject || '';
    tr.append(th1, th2);

    dates.forEach(d => {
      const td = document.createElement('td');
      td.style.textAlign='center'; td.style.minWidth='90px'; td.style.padding='6px 8px'; td.style.border='1px solid #eee';
      const k = rowKey + '|' + d;
      const tip = tipMap.get(k); if (tip) td.title = tip;

      const baseName = name || '';
      const isAbsent = absPairs.has(JSON.stringify([rowKey, d])) || absNameDate.has(JSON.stringify([baseName, d]));
      if (isAbsent) {
        td.style.background = COLOR.absent; td.textContent = 'Absent';
      } else {
        const v = valMap.get(k);
        td.style.background = statusColor(v);
        td.textContent = (v==null ? '' : String(v));
      }
      tr.appendChild(td);
    });

    els.tbody.appendChild(tr);
  });

  // subject checkboxes
  els.subjects.innerHTML = '';
  const subjList = Array.from(subjects).sort();
  if (subjList.length) {
    const wrap = document.createElement('div'); wrap.style.marginTop='6px';
    let htmlChecks = '<strong>Subjects:</strong> ';
    subjList.forEach(s => { htmlChecks += `<label style="margin-right:12px;"><input type="checkbox" class="subj" value="${esc(s)}" checked/> ${esc(s)}</label>`; });
    htmlChecks += `<button onclick="selectAllSubjects(true)" style="margin-left:8px;">Select All</button>`;
    htmlChecks += `<button onclick="selectAllSubjects(false)" style="margin-left:6px;">Clear</button>`;
    wrap.innerHTML = htmlChecks; els.subjects.appendChild(wrap);
  }

  // filtering
  const filterRows = () => {
    const q = (els.q.value || '').toLowerCase();
    const trs = document.querySelectorAll('tbody tr');
    const chk = document.querySelectorAll('input.subj');
    const useSubj = chk.length > 0;
    const sel = new Set(); chk.forEach(b => { if (b.checked) sel.add(b.value.toLowerCase()); });
    trs.forEach(tr => {
      const nameTxt = tr.children[0].textContent.toLowerCase();
      const subjTxt = (tr.getAttribute('data-subject') || tr.children[1].textContent).toLowerCase();
      const matchQ = !q || nameTxt.includes(q) || subjTxt.includes(q);
      const matchS = !useSubj || sel.has(subjTxt) || subjTxt === '';
      tr.style.display = (matchQ && matchS) ? '' : 'none';
    });
  };
  window.selectAllSubjects = (state) => { document.querySelectorAll('input.subj').forEach(b => b.checked=state); filterRows(); };
  els.q.oninput = filterRows;
  document.addEventListener('change', e => { if (e.target && e.target.classList.contains('subj')) filterRows(); });
  filterRows();

  els.status.textContent = `Built ${dates.length} date columns Â· ${rowKeys.length} rows`;
}

// wire up
document.getElementById('reload').onclick = loadCSVs;
document.getElementById('build').onclick = buildCalendar;

// auto-load on first visit
loadCSVs();
</script>
</body>
</html>
