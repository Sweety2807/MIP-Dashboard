<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ðŸ“… MIP Calendar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- CSV + date parsing libs -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/customParseFormat.js"></script>
  <style>
    :root{ --nameW: 200px; --subjW: 160px; }
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;margin:24px;color:#0f172a}
    table{border-collapse:collapse;width:100%;table-layout:fixed}
    th,td{border:1px solid #e5e7eb}
    thead th{position:sticky;top:0;background:#f8fafc;z-index:3}
    tbody th{background:#fff}
    .container{overflow:auto;max-width:100%}
    .controls>*{margin-right:12px}
    #q{padding:6px 10px;border:1px solid #cbd5e1;border-radius:8px}
    .chip{padding:4px 8px;border-radius:8px;margin-left:8px;display:inline-block}
    .panel{border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin:8px 0 16px 0;background:#fafafa}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    select,input[type="text"],input[type="number"]{padding:6px 10px;border:1px solid #cbd5e1;border-radius:8px}
    button{padding:6px 10px;border:1px solid #cbd5e1;border-radius:8px;background:#fff;cursor:pointer}

    /* Sticky first two columns use CSS vars so header/body stay aligned */
    thead th.name, tbody th.name{min-width:var(--nameW); width:var(--nameW); left:0; position:sticky; z-index:3}
    thead th.subj, tbody th.subj{min-width:var(--subjW); width:var(--subjW); left:var(--nameW); position:sticky; z-index:3}

    /* Student separators */
    tbody tr.student-sep th,
    tbody tr.student-sep td { border-top: 3px solid #94a3b8; }
    tbody tr.student-gap td { padding: 4px 0 !important; border: none !important; background: transparent !important; }

    /* Cells */
    td{ text-align:center; min-width:90px; padding:6px 8px; border:1px solid #eee; }
    td .pill{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; line-height:18px; background:rgba(255,255,255,.6)}

    .muted{color:#64748b}
  </style>
</head>
<body>
  <h1>ðŸ“… MIP Calendar</h1>
  <p><strong>Rows:</strong> Name &amp; Subject (separate columns) &nbsp;&nbsp;
     <strong>Columns:</strong> Date &nbsp;&nbsp;
     <strong>Cells:</strong> MIP (or <em>Absent</em>)</p>
  <div style="margin:8px 0 16px 0;">
    <strong>Legend:</strong>
    <span class="chip" style="background:#A5D6A7;">On Track</span>
    <span class="chip" style="background:#FFF59D;">Spend More Time</span>
    <span class="chip" style="background:#EF9A9A;">Low Efficiency / Idling</span>
    <span class="chip" style="background:#CFD8DC;">Absent</span>
    <span class="chip" style="background:#EEEEEE;">No Data</span>
  </div>

  <!-- Mapping panel -->
  <div class="panel">
    <div class="row">
      <div>
        <label>MIP CSV:</label>
        <input id="mipFileName" value="mip.csv" style="width:180px"/>
      </div>
      <div>
        <label>Absent CSV (optional):</label>
        <input id="absFileName" value="absent.csv" style="width:180px"/>
      </div>
      <button id="reload">Load CSVs</button>
    </div>
    <div class="row" style="margin-top:10px">
      <div>
        <label>Name column:</label>
        <select id="nameCol"></select>
      </div>
      <div>
        <label>Subject column:</label>
        <select id="subjCol"></select>
      </div>
      <div>
        <label>MIP column:</label>
        <select id="mipCol"></select>
      </div>
      <div>
        <label>Date column:</label>
        <select id="dateCol"></select>
      </div>
      <div>
        <label>Date format:</label>
        <select id="dateFmt">
          <option value="auto">Auto detect</option>
          <option value="DD/MM/YY" selected>DD/MM/YY (e.g. 31/08/25)</option>
          <option value="DD/MM/YYYY">DD/MM/YYYY</option>
          <option value="MM/DD/YYYY">MM/DD/YYYY</option>
          <option value="YYYY-MM-DD">YYYY-MM-DD</option>
          <option value="DD-MM-YYYY">DD-MM-YYYY</option>
          <option value="YYYY/MM/DD">YYYY/MM/DD</option>
        </select>
      </div>
      <div>
        <label>Sticky widths:</label>
        <input id="nameW" type="number" value="200" min="120" style="width:80px"> px
        <input id="subjW" type="number" value="160" min="120" style="width:80px; margin-left:8px;"> px
      </div>
      <button id="build">Build Calendar</button>
    </div>
  </div>

  <div class="controls" style="margin:8px 0 12px 0;">
    <label>Search:</label> <input id="q" placeholder="Type name or subject..." />
  </div>
  <div id="subjects"></div>

  <div class="container" style="margin-top:8px;">
    <table>
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <p id="status" class="muted" style="margin-top:12px;"></p>

<script>
// ===== libs =====
dayjs.extend(dayjs_plugin_customParseFormat);

// ===== Config =====
const COLOR = { onTrack:'#A5D6A7', spendMore:'#FFF59D', red:'#EF9A9A', absent:'#CFD8DC', none:'#EEEEEE' };
const USE_STUDENT_GAP = false;

// ===== State & Elements =====
let mipRows = [], absRows = [];
let allCols = [];
const els = {
  nameCol: document.getElementById('nameCol'),
  subjCol: document.getElementById('subjCol'),
  mipCol:  document.getElementById('mipCol'),
  dateCol: document.getElementById('dateCol'),
  dateFmt: document.getElementById('dateFmt'),
  thead:   document.getElementById('thead'),
  tbody:   document.getElementById('tbody'),
  q:       document.getElementById('q'),
  status:  document.getElementById('status'),
  subjects:document.getElementById('subjects'),
  mipFileName: document.getElementById('mipFileName'),
  absFileName: document.getElementById('absFileName'),
  nameW: document.getElementById('nameW'),
  subjW: document.getElementById('subjW'),
};

// ===== Helpers =====
const parseCSV = async (url) => {
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
  const text = await res.text();
  return new Promise((resolve, reject) => {
    Papa.parse(text, {header:true, skipEmptyLines:true, complete: r=>resolve(r.data), error: reject});
  });
};

const findCol = (rows, candidates) => {
  if (!rows.length) return null;
  const cols = Object.keys(rows[0]);
  for (const cand of candidates) { const hit = cols.find(c => c.toLowerCase() === cand.toLowerCase()); if (hit) return hit; }
  for (const cand of candidates) { const hit = cols.find(c => c.toLowerCase().includes(cand.toLowerCase())); if (hit) return hit; }
  return null;
};

const toISODate = (v, fmt) => {
  if (!v) return null;
  if (fmt && fmt !== 'auto') { const d = dayjs(v, fmt, true); return d.isValid() ? d.format('YYYY-MM-DD') : null; }
  let d = dayjs(v);
  if (!d.isValid()) d = dayjs(v, 'YYYY-MM-DD', true);
  if (!d.isValid()) d = dayjs(v, 'DD/MM/YYYY', true);
  if (!d.isValid()) d = dayjs(v, 'MM/DD/YYYY', true);
  if (!d.isValid()) d = dayjs(v, 'DD-MM-YYYY', true);
  if (!d.isValid()) d = dayjs(v, 'YYYY/MM/DD', true);
  if (!d.isValid()) d = dayjs(v, 'DD/MM/YY', true);
  if (!d.isValid()) d = dayjs(v, 'MM/DD/YY', true);
  if (!d.isValid()) d = dayjs(v, 'DD-MM-YY', true);
  return d.isValid() ? d.format('YYYY-MM-DD') : null;
};

const statusColor = (val) => {
  if (val == null || val === "") return COLOR.none;
  const s = String(val).trim().toLowerCase();
  if (s === "on track") return COLOR.onTrack;
  if (s === "spend more time") return COLOR.spendMore;
  if (s === "probable idling/inflated time" || s.includes("low efficiency") || s.includes("idling") || s.includes("inflated")) return COLOR.red;
  return COLOR.none;
};

const esc = (s) => String(s ?? "").replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));

// Build tooltip content WITHOUT relying on brittle column indices.
// Show all columns except the four selected mapping columns.
const buildTooltip = (raw, omitKeys) => {
  const lines = [];
  for (const k of Object.keys(raw)) {
    if (omitKeys.has(k)) continue;
    const v = raw[k];
    if (v !== undefined && v !== null && String(v).trim() !== '') lines.push(`${k}: ${v}`);
  }
  return lines.join('\n');
};

// ===== Load CSVs & guess columns =====
async function loadCSVs() {
  els.status.textContent = 'Loading...';
  try { mipRows = await parseCSV(els.mipFileName.value.trim()); els.status.textContent = 'Loaded ' + els.mipFileName.value.trim(); }
  catch(e) { els.status.textContent = 'Could not load ' + els.mipFileName.value.trim() + ': ' + e.message; mipRows = []; }
  try { absRows = await parseCSV(els.absFileName.value.trim()); els.status.textContent += ' + ' + els.absFileName.value.trim(); }
  catch { absRows = []; }

  if (!mipRows.length) return;

  allCols = Object.keys(mipRows[0]);
  const guesses = {
    name:  findCol(mipRows, ['name','student name','learner','child']) || allCols[0],
    subj:  findCol(mipRows, ['subject','course','class']) || '',
    mip:   findCol(mipRows, ['mip','status','progress','metric']) || allCols[0],
    date:  findCol(mipRows, ['date','activity date','session date','day']) || allCols.find(c=>/date|day/i.test(c)) || allCols[0],
  };

  const fill = (sel, allowEmpty=false) => {
    sel.innerHTML = allowEmpty ? '<option value="">(none)</option>' : '';
    for (const c of allCols) sel.innerHTML += `<option value="${esc(c)}">${esc(c)}</option>`;
  };
  fill(els.nameCol); fill(els.subjCol, true); fill(els.mipCol); fill(els.dateCol);

  els.nameCol.value = guesses.name;
  els.subjCol.value = guesses.subj;
  els.mipCol.value  = guesses.mip;
  els.dateCol.value = guesses.date;
}

// ===== Build calendar =====
function buildCalendar() {
  // Update sticky widths (keeps header/body aligned and fixes overlap in screenshots)
  document.documentElement.style.setProperty('--nameW', els.nameW.value + 'px');
  document.documentElement.style.setProperty('--subjW', els.subjW.value + 'px');

  const nameCol = els.nameCol.value;
  const subjCol = els.subjCol.value || null;
  const mipCol  = els.mipCol.value;
  const dateCol = els.dateCol.value;
  const fmt     = els.dateFmt.value;

  if (!mipRows.length) { els.status.textContent = 'Load CSVs first.'; return; }

  // Normalize dates & build keys
  const rows = mipRows
    .map(r => {
      const iso = toISODate(r[dateCol], fmt);
      if (!iso) return null;
      const rowKey = subjCol ? JSON.stringify([String(r[nameCol]||''), String(r[subjCol]||'')]) : String(r[nameCol]||'');
      return { __date: iso, __row: rowKey, __name: String(r[nameCol]||''), __subj: subjCol ? String(r[subjCol]||'') : '', __mip: r[mipCol], _raw: r };
    })
    .filter(Boolean);

  if (!rows.length) { els.status.textContent = 'No valid dates after parsing. Check Date column/format.'; return; }

  // keep last per (__row,__date)
  const map = new Map(); rows.forEach(r => map.set(r.__row + '|' + r.__date, r));
  const dedup = Array.from(map.values());

  // absences
  const absPairs = new Set(), absNameDate = new Set();
  if (absRows.length) {
    const aName = findCol(absRows, [els.nameCol.value,'name','student name','learner','child']) || Object.keys(absRows[0])[0];
    const aSubj = subjCol ? findCol(absRows, [els.subjCol.value,'subject','course','class']) : null;
    const aDate = findCol(absRows, ['date','activity date','session date','day']) || els.dateCol.value;
    const aFlag = findCol(absRows, ['absent','attendance','status']);
    absRows.forEach(r => {
      const iso = toISODate(r[aDate], fmt) || toISODate(r[aDate], 'auto');
      const flag = aFlag ? String(r[aFlag]||'').trim().toLowerCase() : 'absent';
      const isAbsent = ['absent','a','true','1','yes'].includes(flag) || (aFlag==null);
      if (!iso || !isAbsent) return;
      if (aSubj) { const key = JSON.stringify([String(r[aName]||''), String(r[aSubj]||'')]); absPairs.add(JSON.stringify([key, iso])); }
      else { absNameDate.add(JSON.stringify([String(r[aName]||''), iso])); }
    });
  }

  // row keys & dates
  const rowKeys = Array.from(new Set(dedup.map(r => r.__row)));
  const dates = Array.from(new Set(dedup.map(r => r.__date))).sort();

  // maps
  const valMap = new Map(), tipMap = new Map();
  const omit = new Set([els.nameCol.value, els.subjCol.value, els.mipCol.value, els.dateCol.value].filter(Boolean));
  dedup.forEach(r => { const k=r.__row+'|'+r.__date; valMap.set(k, r.__mip); tipMap.set(k, buildTooltip(r._raw, omit)); });

  // render header
  els.thead.innerHTML = '';
  const trh = document.createElement('tr');
  const thN = document.createElement('th'); thN.className='name'; thN.textContent='Name';
  const thS = document.createElement('th'); thS.className='subj'; thS.textContent='Subject';
  trh.append(thN, thS);
  dates.forEach(d => { const th=document.createElement('th'); th.textContent=d; trh.appendChild(th); });
  els.thead.appendChild(trh);

  // rows + separators
  els.tbody.innerHTML = '';
  const subjects = new Set();
  let prevName = null;

  const frag = document.createDocumentFragment();
  rowKeys.forEach((rowKey) => {
    let name = rowKey, subject = '';
    try { const a=JSON.parse(rowKey); name=a[0]; subject=a[1]||''; } catch {}
    if (subject) subjects.add(subject);

    if (USE_STUDENT_GAP && prevName !== null && name !== prevName) {
      const gap = document.createElement('tr');
      gap.className = 'student-gap';
      const td = document.createElement('td');
      td.colSpan = 2 + dates.length; // Name + Subject + dates
      gap.appendChild(td);
      frag.appendChild(gap);
    }

    const tr = document.createElement('tr');
    tr.setAttribute('data-subject', subject || '');
    if (prevName !== null && name !== prevName) tr.classList.add('student-sep');
    prevName = name;

    const th1 = document.createElement('th'); th1.className='name'; th1.style.textAlign='left'; th1.style.whiteSpace='nowrap'; th1.textContent = name || '';
    const th2 = document.createElement('th'); th2.className='subj'; th2.style.textAlign='left'; th2.style.whiteSpace='nowrap'; th2.textContent = subject || '';
    tr.append(th1, th2);

    dates.forEach(d => {
      const td = document.createElement('td');
      const k = rowKey + '|' + d;
      const tip = tipMap.get(k); if (tip) td.title = tip;
      const isAbsent = absPairs.has(JSON.stringify([rowKey, d])) || absNameDate.has(JSON.stringify([name || '', d]));
      if (isAbsent) { td.style.background = COLOR.absent; td.innerHTML = '<span class="pill">Absent</span>'; }
      else { const v = valMap.get(k); td.style.background = statusColor(v); td.textContent = (v==null ? '' : String(v)); }
      tr.appendChild(td);
    });

    frag.appendChild(tr);
  });
  els.tbody.appendChild(frag);

  // subject checkboxes
  els.subjects.innerHTML = '';
  const subjList = Array.from(subjects).sort();
  if (subjList.length) {
    const wrap = document.createElement('div'); wrap.style.marginTop='6px';
    let htmlChecks = '<strong>Subjects:</strong> ';
    subjList.forEach(s => { htmlChecks += `<label style="margin-right:12px;"><input type="checkbox" class="subj" value="${esc(s)}" checked/> ${esc(s)}</label>`; });
    htmlChecks += `<button type="button" onclick="selectAllSubjects(true)" style="margin-left:8px;">Select All</button>`;
    htmlChecks += `<button type="button" onclick="selectAllSubjects(false)" style="margin-left:6px;">Clear</button>`;
    wrap.innerHTML = htmlChecks; els.subjects.appendChild(wrap);
  }

  // filtering
  const filterRows = () => {
    const q = (els.q.value || '').toLowerCase();
    const trs = document.querySelectorAll('tbody tr');
    const chk = document.querySelectorAll('input.subj');
    const useSubj = chk.length > 0;
    const sel = new Set(); chk.forEach(b => { if (b.checked) sel.add(b.value.toLowerCase()); });
    trs.forEach(tr => {
      const nameTxt = tr.children[0].textContent.toLowerCase();
      const subjTxt = (tr.getAttribute('data-subject') || tr.children[1].textContent).toLowerCase();
      const matchQ = !q || nameTxt.includes(q) || subjTxt.includes(q);
      const matchS = !useSubj || sel.has(subjTxt) || subjTxt === '';
      tr.style.display = (matchQ && matchS) ? '' : 'none';
    });
  };
  window.selectAllSubjects = (state) => { document.querySelectorAll('input.subj').forEach(b => b.checked=state); filterRows(); };
  els.q.oninput = filterRows;
  document.addEventListener('change', e => { if (e.target && e.target.classList.contains('subj')) filterRows(); });
  filterRows();

  els.status.textContent = `Built ${dates.length} date columns Â· ${rowKeys.length} rows`;
}

// wire up
function applyWidths(){
  document.documentElement.style.setProperty('--nameW', els.nameW.value + 'px');
  document.documentElement.style.setProperty('--subjW', els.subjW.value + 'px');
}
['input','change'].forEach(ev=>{ els.nameW.addEventListener(ev, applyWidths); els.subjW.addEventListener(ev, applyWidths); });

document.getElementById('reload').onclick = loadCSVs;
document.getElementById('build').onclick   = buildCalendar;

// auto-load on first visit
loadCSVs();
applyWidths();
</script>
</body>
</html>
