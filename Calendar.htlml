<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ðŸ“… MIP Calendar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- PapaParse for robust CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; margin: 24px; }
    table { border-collapse: collapse; width: 100%; table-layout: fixed; }
    th, td { border: 1px solid #e5e7eb; }
    thead th { position: sticky; top: 0; background: #f8fafc; z-index: 3; }
    tbody th { background: #fff; }
    .container { overflow:auto; max-width: 100%; }
    .controls > * { margin-right: 12px; }
    #q { padding:6px 10px; border:1px solid #cbd5e1; border-radius:8px; }
    .chip { padding:4px 8px; border-radius:8px; margin-left:8px; display:inline-block; }
  </style>
</head>
<body>
  <h1>ðŸ“… MIP Calendar</h1>
  <p><strong>Rows:</strong> Name &amp; Subject (separate columns) &nbsp;&nbsp;
     <strong>Columns:</strong> Date &nbsp;&nbsp;
     <strong>Cells:</strong> MIP (or <em>Absent</em>)</p>
  <div style="margin:8px 0 16px 0;">
    <strong>Legend:</strong>
    <span class="chip" style="background:#A5D6A7;">On Track</span>
    <span class="chip" style="background:#FFF59D;">Spend More Time</span>
    <span class="chip" style="background:#EF9A9A;">Low Efficiency / Idling</span>
    <span class="chip" style="background:#CFD8DC;">Absent</span>
    <span class="chip" style="background:#EEEEEE;">No Data</span>
  </div>

  <div class="controls" style="margin:8px 0 12px 0;">
    <label>Search:</label> <input id="q" placeholder="Type name or subject..." />
  </div>
  <div id="subjects"></div>

  <div class="container" style="margin-top:8px;">
    <table>
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <p id="status" style="margin-top:12px;color:#64748b;"></p>

<script>
(async function () {
  // Config
  const MIP_FILE = 'mip.csv';           // required
  const ABSENT_FILE = 'absent.csv';     // optional
  const HOVER_INDICES = [4,5,6,7,8,9,12]; // E..J and M (0-based)

  // Colors
  const COLOR = {
    onTrack: '#A5D6A7',
    spendMore: '#FFF59D',
    red: '#EF9A9A',
    absent: '#CFD8DC',
    none: '#EEEEEE'
  };

  const statusEl = document.getElementById('status');

  // Utils
  const parseCSV = async (url) => {
    const res = await fetch(url, {cache:'no-store'});
    if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
    const text = await res.text();
    return new Promise((resolve, reject) => {
      Papa.parse(text, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: (result) => resolve(result.data),
        error: reject
      });
    });
  };

  const findCol = (rows, candidates) => {
    if (!rows.length) return null;
    const cols = Object.keys(rows[0]);
    // exact
    for (const cand of candidates) {
      const hit = cols.find(c => c.toLowerCase() === cand.toLowerCase());
      if (hit) return hit;
    }
    // contains
    for (const cand of candidates) {
      const hit = cols.find(c => c.toLowerCase().includes(cand.toLowerCase()));
      if (hit) return hit;
    }
    return null;
  };

  const detectDateCol = (rows) => {
    const preferred = findCol(rows, ["date","activity date","session date","day"]);
    if (preferred) return preferred;
    const cols = Object.keys(rows[0] || {});
    let best = null, bestScore = 0;
    for (const c of cols) {
      let ok = 0;
      for (const r of rows.slice(0, 200)) {
        const v = r[c];
        if (v && !isNaN(Date.parse(v))) ok++;
      }
      const score = ok / Math.min(rows.length, 200);
      if (score > bestScore) { bestScore = score; best = c; }
    }
    return best;
  };

  const toISODate = (v) => {
    const d = new Date(v);
    if (isNaN(d)) return null;
    // Use YYYY-MM-DD only
    const iso = d.toISOString();
    return iso.slice(0,10);
  };

  const statusColor = (val) => {
    if (val == null || val === "") return COLOR.none;
    const s = String(val).trim().toLowerCase();
    if (s === "on track") return COLOR.onTrack;
    if (s === "spend more time") return COLOR.spendMore;
    if (s === "probable idling/inflated time" || s.includes("low efficiency") || s.includes("idling") || s.includes("inflated")) return COLOR.red;
    // default gray
    return COLOR.none;
  };

  const escapeHtml = (s) => String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));

  try {
    // Load MIP
    const mip = await parseCSV(MIP_FILE);

    if (!mip.length) {
      statusEl.textContent = "No rows in mip.csv";
      return;
    }

    // Detect columns
    const nameCol = findCol(mip, ["name","student name","learner","child"]) || Object.keys(mip[0])[0];
    const subjectCol = findCol(mip, ["subject","course","class"]); // optional
    const mipCol = findCol(mip, ["mip","status","progress","metric"]);
    const dateCol = detectDateCol(mip);

    if (!mipCol || !dateCol) {
      statusEl.textContent = `Could not detect needed columns. Found: ${Object.keys(mip[0]).join(", ")}`;
      return;
    }

    // Normalize dates; build row key
    for (const r of mip) r.__date = toISODate(r[dateCol]);
    const mipClean = mip.filter(r => r.__date);

    for (const r of mipClean) {
      r.__row = subjectCol ? JSON.stringify([String(r[nameCol]||""), String(r[subjectCol]||"")]) : String(r[nameCol]||"");
    }

    // Tooltips (columns E..J and M by index among the original order)
    const allCols = Object.keys(mip[0] || {});
    const mkTooltip = (r) => {
      const parts = [];
      for (const idx of HOVER_INDICES) {
        if (idx >= 0 && idx < allCols.length) {
          const k = allCols[idx];
          parts.push(`${k}: ${r[k] ?? ""}`);
        }
      }
      return parts.join("\n");
    };
    for (const r of mipClean) r.__tip = mkTooltip(r);

    // Deduplicate per (__row, __date), keep last
    const keySet = new Set();
    const mipDedup = [];
    for (const r of mipClean) {
      const key = r.__row + "|" + r.__date;
      if (keySet.has(key)) continue;
      keySet.add(key);
      mipDedup.push(r);
    }

    // Absent (optional)
    let absentPairs = new Set();      // key: JSON.stringify([rowKey, date])
    let absentNameDate = new Set();   // key: JSON.stringify([name, date])
    try {
      const abs = await parseCSV(ABSENT_FILE);
      if (abs.length) {
        const aName = findCol(abs, [nameCol,"name","student name","learner","child"]) || Object.keys(abs[0])[0];
        const aSubj = subjectCol ? findCol(abs, [subjectCol,"subject","course","class"]) : null;
        const aDate = findCol(abs, ["date","activity date","session date","day"]) || dateCol;
        const aFlag = findCol(abs, ["absent","attendance","status"]);

        for (const r of abs) {
          const flag = aFlag ? String(r[aFlag]||"").trim().toLowerCase() : "absent";
          const isAbsent = ["absent","a","true","1","yes"].includes(flag) || aFlag == null; // if no flag, treat rows as absent
          const d = toISODate(r[aDate]);
          if (!isAbsent || !d) continue;

          if (subjectCol && aSubj) {
            const rowKey = JSON.stringify([String(r[aName]||""), String(r[aSubj]||"")]);
            absentPairs.add(JSON.stringify([rowKey, d]));
          } else {
            absentNameDate.add(JSON.stringify([String(r[aName]||""), d]));
          }
        }
      }
    } catch (e) {
      // No absent.csv present is fine
    }

    // Build pivot indices
    const rowKeys = Array.from(new Set(mipDedup.map(r => r.__row)));
    const dates = Array.from(new Set(mipDedup.map(r => r.__date))).sort();

    // Map rowKey+date -> MIP and tip
    const valMap = new Map();
    const tipMap = new Map();
    for (const r of mipDedup) {
      valMap.set(r.__row + "|" + r.__date, r[mipCol]);
      tipMap.set(r.__row + "|" + r.__date, r.__tip);
    }

    // Helpers to split name/subject
    const splitRow = (rowKey) => {
      try {
        const arr = JSON.parse(rowKey);
        return {name: arr[0], subject: arr[1] ?? ""};
      } catch {
        return {name: rowKey, subject: ""};
      }
    };

    // Build THEAD
    const thead = document.getElementById('thead');
    const thRow = document.createElement('tr');
    const thName = document.createElement('th');
    thName.style.position = 'sticky'; thName.style.left = '0'; thName.style.background = '#fafafa'; thName.style.zIndex = '3';
    thName.textContent = 'Name';
    const thSubj = document.createElement('th');
    thSubj.style.position = 'sticky'; thSubj.style.left = '120px'; thSubj.style.background = '#fafafa'; thSubj.style.zIndex = '3';
    thSubj.textContent = 'Subject';
    thRow.append(thName, thSubj);
    for (const d of dates) {
      const th = document.createElement('th');
      th.textContent = d;
      thRow.appendChild(th);
    }
    thead.appendChild(thRow);

    // Build TBODY rows
    const tbody = document.getElementById('tbody');
    const subjects = new Set();

    rowKeys.forEach(rowKey => {
      const {name, subject} = splitRow(rowKey);
      if (subject) subjects.add(subject);

      const tr = document.createElement('tr');
      tr.setAttribute('data-subject', subject || "");

      const thN = document.createElement('th');
      thN.style.position = 'sticky'; thN.style.left = '0'; thN.style.background = '#fff'; thN.style.zIndex = '2';
      thN.style.textAlign = 'left'; thN.style.whiteSpace = 'nowrap';
      thN.textContent = name || "";
      const thS = document.createElement('th');
      thS.style.position = 'sticky'; thS.style.left = '120px'; thS.style.background = '#fff'; thS.style.zIndex = '2';
      thS.style.textAlign = 'left'; thS.style.whiteSpace = 'nowrap';
      thS.textContent = subject || "";

      tr.append(thN, thS);

      for (const d of dates) {
        const td = document.createElement('td');
        td.style.textAlign = 'center';
        td.style.minWidth = '90px';
        td.style.padding = '6px 8px';
        td.style.border = '1px solid #eee';

        const key = rowKey + "|" + d;
        const tip = tipMap.get(key);
        if (tip) td.title = tip;

        // Absent?
        const baseName = splitRow(rowKey).name || "";
        const isAbsent = absentPairs.has(JSON.stringify([rowKey, d])) ||
                         absentNameDate.has(JSON.stringify([baseName, d]));

        if (isAbsent) {
          td.style.background = COLOR.absent;
          td.textContent = "Absent";
        } else {
          const v = valMap.get(key);
          td.style.background = statusColor(v);
          td.textContent = (v == null ? "" : String(v));
        }

        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    });

    // Subject multi-select checkboxes
    const subjDiv = document.getElementById('subjects');
    const subjList = Array.from(subjects).sort();
    if (subjList.length) {
      const wrap = document.createElement('div');
      wrap.style.marginTop = '6px';
      let htmlChecks = '<strong>Subjects:</strong> ';
      for (const s of subjList) {
        htmlChecks += `<label style="margin-right:12px;"><input type="checkbox" class="subj" value="${escapeHtml(s)}" checked/> ${escapeHtml(s)}</label>`;
      }
      htmlChecks += `<button onclick="selectAllSubjects(true)" style="margin-left:8px;padding:4px 8px;">Select All</button>`;
      htmlChecks += `<button onclick="selectAllSubjects(false)" style="margin-left:6px;padding:4px 8px;">Clear</button>`;
      wrap.innerHTML = htmlChecks;
      subjDiv.appendChild(wrap);
    }

    // Filtering
    const filterRows = () => {
      const q = (document.getElementById('q')?.value || "").toLowerCase();
      const trs = document.querySelectorAll('tbody tr');
      const chk = document.querySelectorAll('input.subj');
      const useSubj = chk.length > 0;
      const sel = new Set();
      chk.forEach(b => { if (b.checked) sel.add(b.value.toLowerCase()); });

      trs.forEach(tr => {
        const nameTxt = tr.children[0].textContent.toLowerCase();
        const subjTxt = (tr.getAttribute('data-subject') || tr.children[1].textContent).toLowerCase();
        const matchQ = !q || nameTxt.includes(q) || subjTxt.includes(q);
        const matchS = !useSubj || sel.has(subjTxt) || subjTxt === "";
        tr.style.display = (matchQ && matchS) ? '' : 'none';
      });
    };

    window.selectAllSubjects = (state) => {
      document.querySelectorAll('input.subj').forEach(b => b.checked = state);
      filterRows();
    };

    document.getElementById('q').addEventListener('input', filterRows);
    document.addEventListener('change', (e) => {
      if (e.target && e.target.classList.contains('subj')) filterRows();
    });

    // Initial filter run
    filterRows();
    statusEl.textContent = "Loaded mip.csv" + (absentPairs.size || absentNameDate.size ? " + absent.csv" : "");
  } catch (e) {
    document.getElementById('status').textContent = "Error: " + e.message;
    console.error(e);
  }
})();
</script>
</body>
</html>
